# Модели счетных данных {#poisreg}


```{r setup, include=FALSE}
library(knitr)
library(texreg)
library(Statamarkdown)
library(reticulate)
stataexe <- find_stata()
stataexe = "C:/Program Files (x86)/Stata13/StataMP-64.exe"
knitr::opts_chunk$set(engine.path = list(stata = stataexe), collectcode = TRUE)
```

Загрузим необходимые пакеты.
```{r "packages", results='hide', message=FALSE, warning=FALSE}
library(tidyverse) #работа с данными и графики
library(skimr) #красивое summary
library(rio) #чтение .dta файлов
library(vcd) #еще графики
library(MASS) #отрицательное биномиальное
library(lmtest) #для проверки гипотез
library(pscl) #zero-inflation function
library(margins) #для подсчета предельных эффектов
```

Импортируем данные.
```{r "import data"}
df = import(file = "fish.dta")
```
Данные содержат информацию о количестве рыбы, пойманной людьми на отдыхе. 

Camper - наличие/отсутсвие палатки.
Child - количество детей, которых взяли на рыбалку.
Persons - количество людей в группе.
Count - количество пойманной рыбы


Посмотрим нам описательные статистики. 
```{r "skim"}
skim_with(numeric = list(hist = NULL, p25 = NULL, p75 = NULL))
skim(df)
```

Переменная `camper` принимает всего два значения, поэтому превратим ее в факторную переменную.

```{r "factor"}
df = mutate(df, camper = factor(camper))
```

Наша задача - по имеющимся данным предсказать улов. Для начала посмотрим на распределение объясняемой переменной `count`.
```{r "hist"}
ggplot(df, aes(x = count)) + geom_histogram(binwidth = 1) + labs(x = 'count', y = 'frequency', title = 'Distribution of count variable')
```

Предположим, что переменная имеет распределение Пуассона. Будем использовать пуассоновскую регрессию. 
\[
P(y=k)=exp(-\lambda) \lambda^k / k!
\]
где $\lambda=\exp(b_1 +b_2*x)$

```{r "poisson"}
poisson = glm(count ~ child + camper +  persons, family = "poisson", data = df)
summary(poisson)
```

Посчитаем средний предельный эффект для каждоый переменной.
```{r "mef"}
colMeans(marginal_effects(poisson))
```

Однако, заметим, что дисперсия и среднее значение объясняемой переменной не равны, как это предполагает распределение Пуассона.
```{r "with"}
df %>% group_by(camper) %>% summarize(var = var(count), mean = mean(count))
```

Оценим регрессию, предполагая отрицательное биномиальное распределение остатков. В этом случае, дисперсия распределения зависит от некоторого параметра и не равна среднему.

```{r "nb"}
nb1 = glm.nb(count ~ child + camper +  persons, data = df)
summary(nb1)
```

Попробуем исключить из модели переменную `camper` и сравним качество двух моделей.
```{r "excl"}
nb2 = update(nb1, . ~ . - camper)
waldtest(nb1, nb2)
```

Посчитаем предельный эффект в какой-нибудь точке.
```{r "mf"}
marginal_effects(poisson)
```

Можем посмотреть на результаты модели с "раздутыми нулями" (zero-inflated). Они предполагают большую частоту нулевых наблюдений.
```{r "zero_infl"}
zero_infl = zeroinfl(count ~ child + camper | persons, data = df, dist = 'negbin')
summary(zero_infl)
```


#### То же самое в стате

Загружаем данные и смотрим описательные статистики.

```{stata}
use fish.dta
summarize
```

```{stata}
hist count
```

Строим Пуассоновскую регрессию. 
В описательных статистиках:
$AIC = -2log(L) + 2k$
$AIC = -2log(L) + klog(N)$


```{stata}
glm count camper child persons, family(poisson)
```

Можем посчитать AIC и BIC по другой формуле, аналогично выводу R.
$AIC = \frac {-2log(L) + 2k}{N}$
```{stata}                
estat ic
```

Посмотрим, равны ли среднее значение и дисперсия, как это предполагает распределение Пуассона.
```{stata}
tabstat count, by(camper) stat(mean, variance) nototal
```

Предположим, что остатки имеют отрицательное биномиальное распределение.
```{stata}
nbreg count child camper persons
```
 
Проверим гипотезу о равенстве 0 коэффицинта при переменной `camper`. Проведем тест Вальда.
```{stata}
quietly: nbreg count child i.camper persons #скрыть вывод регрессии
test i.camper 
```

Посчитаем средний предельный эффект для каждоый переменной.
```{stata}                
margins, dydx(*)
```

И модель с раздутыми нулями.
```{stata}  
zinb count child i.camper, inflate(persons)
```
